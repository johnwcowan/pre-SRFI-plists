<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>SRFI ###: Property Lists</title>
    <link href="/favicon.png" rel="icon" sizes="192x192" type="image/png">
    <link rel="stylesheet" href="https://srfi.schemers.org/srfi.css" type="text/css">
    <meta name="viewport" content="width=device-width, initial-scale=1"></head>
  <body>
    <h1><a href="https://srfi.schemers.org/"><img class="srfi-logo" src="https://srfi.schemers.org/srfi-logo.svg" alt="SRFI logo" /></a>###: Property Lists</h1>

<p>
by John Cowan (author and editor) and Harold Ancell (scribe)
</p>

<h2 id="status">Status</h2>

<ul>
  <li>John Cowans' <a href="https://github.com/johnwcowan/srfi-???">personal
    Git repo for this SRFI</a> for reference while the SRFI is in
    <em>draft</em> status (<a href="https://htmlpreview.github.io/?https://github.com/johnwcowan/srfi-???/blob/master/srfi-???.html">preview</a>)</li>
</ul>


<h2 id="abstract">Abstract</h2>

<p>
Property lists (plists) are a venerable LISP collection type, simple
lists with alternating keys and values, and have some advantages over
the heretofore Scheme standard of association lists (alists).
This SRFI provides plists with tooling comparable to alists.
</p>

<p>
Traditionally, plists have been changed by mutation rather than by
prepending new keys and values as alists are, and these procedures
reflect that convention.
<p>


<h2 id="issues">Issues</h2>

<p>
None at present.
</p>


<h2 id="rationale">Rationale</h2>

<p>
Property lists (plists) and association lists are very light weight key value stores that are alternatives to full fledged hash tables like those provided by <a href="https://srfi.schemers.org/srfi-69/srfi-69.html">SRFI 69</a> and later ones.  They have a variety of use cases, including procedure arguments and return values.

Plists are simple lists with alternating keys and values, e.g. '(k1 v1 k2 v2).  Alists are dotted pairs in a list, the car the key, the cdr the value, e.g. '((k1 . v1) (k2 . v2))).

While both alists and plists use the same number of pairs to represent keys and their values, plists have some advantages over alists.

They require less tying e.g. '(k1 v1 k2 v2) vs. '((k1 . v1) (k2 . v2)), or 13 vs. 21 characters in this simple example.

Some will find them more complex to parse by eye.

They use the same format as keyword arguments, and thus can be passed to a procedure using apply so they will be interpreted as such.

They avoid confusion when a list is stored as a value, an alist entered as '((key . (value1 value2))) prints as '((key value1 value2)).

While alists have the assq et. al. set of procedures, and car and cdr to access the key and value respectively (and those work for the above list as a value example), besides alist-cons, alist-copy, alist-delete, and alist-delete! provided in <a href="https://srfi.schemers.org/srfi-1/srfi-1.html">SRFI 1</a> they have no standardized tooling.  Not much is required for them, but that could be viewed as "a moment of convenience, a lifetime of regret" trade-off.

This SRFI is based on Common Lisp, but is also designed to work with a dictionaries system work in progress.

This SRFI provides a rich set of primitives [extol the virtues of it].
</p>


<h2 id="specification">Specification</h2>

??? detailed specification.  This should be detailed enough that a
conforming implementation could be completely created from this
description.  Please follow the linguistic conventions described in
the <a href="/srfi-faq.html#conventions">FAQ</a>.  In particular,
please follow the conventions about the use of the terms "must," "must
not," "required," "shall," "shall not," "should," "should not,"
"recommended," "may," and "optional" defined by
<a href="https://www.ietf.org/rfc/rfc2119.html">RFC 2119</a>.  This
convention has been adopted by R7RS Small, too, in section 1.3.2
(<a href="https://small.r7rs.org/attachment/r7rs.pdf">PDF</a>).  Also
by convention, the phrase "it is an error to <em>X</em>" is used in
Scheme documents to mean that <em>X</em> is not allowed, but to leave
it up to the implementer to decide what to do in response.
Implementations may signal an error, assign some new meaning to
<em>X</em>, or fail catastrophically.

<p>
Traditional plists use "eq?", but this one uses "eqv?" so that numbers
and characters can be used as keys.
</p>

<p>
Note that this API is for property lists themselves, not for symbols
with property lists attached.
In a system where symbols have plists, you need a primitive to
retrieve the plist associated with the symbol and another to replace
it, and this SRFI can then accept symbols as well as plists.
</p>


<code>(plist-get <i>plist key [failure [success]]</i>)</code> &nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;<i>value</i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)
<blockquote>
<p>
Search for the first value whose key is key and call the success or
failure continuation.
It is an error to search for a key not in the plist and not supply a
failure continuation.
</p>
<pre class="example">
(plist-get '(a 1) 'b)) &rArr; &lt;error&gt;
</pre>
<pre class="example">
(plist-get '(a 1 b 2) 'a) &rArr; 1
</pre>
<pre class="example">
(plist-get '(a 1 b 2) 'b (lambda () #f) (lambda (x) (* x x))) &rArr; 4
</pre>
<pre class="example">
(plist-get '(a 1 b 2) 'c (lambda () #f) (lambda (x) (* x x))) &rArr; #f
</pre>
</blockquote>

<br>

<code>(plist-get/default <i>plist key default</i>)</code> &nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;<i>value</i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)
<blockquote>
<p>
Search for the first value whose key is key and return it or the
default on failure.
</p>
<pre class="example">
(plist-get/default '(a 1 b 2) 'a #t) &rArr; 1
</pre>
<pre class="example">
(plist-get/default '(a 1 b 2) 'c #t) &rArr; #t
</pre>
</blockquote>

<br>

<code>(plist-get-properties <i>plist list-of-keys</i>)</code> &nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;<i>multiple values</i> or <i><code>#f #f #f</code></i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)
<blockquote>
<p>
Searches plist for the first key that is eqv?  to any of the keys in
list-of-keys.
Returns three values: the key, the value, and the tail of the plist
following the value.
If none of the keys are found, return three #f values.
</p>
<pre class="example">
(plist-get-properties '(a 1 b 2) '(c a)) &rArr; a 1 (b 2)
</pre>
<pre class="example">
(plist-get-properties '(a 1) '(b c)) &rArr; #f #f #f
</pre>
</blockquote>

<br>

<code>(plist-put! <i>plist key value</i>)</code> &nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;<i>plist</i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)
<blockquote>
<p>
If the key is in the plist, the pair pointing to its value is mutated.
If the key is not in the plist, the key and values are destructively
appended to the plist.
</p>
<p>
~~~FIX_ME; Is this saying new and old when that's not the case except
for handing it an empty list?

Original text:

This procedure returns the new plist, which normally would be the same
as the old plist, unless the old plist is empty.

Maybe better text:

This procedure returns the plist, which is normally the same as the
submitted plist, unless the submitted plist was empty.
</p>
<pre class="example">
(plist-put! '() 'a 1) &rArr; (a 1)
</pre>
<pre class="example">
(define head (list 'a 1)) &rArr; &lt;undefined&gt;
</pre>
<pre class="example">
(plist-put! head 'b 2) &rArr; (a 1 b 2)
head &rArr; (a 1 b 2)
</pre>
<pre class="example">
(plist-put! head 'a 3) &rArr; (a 3 b 2)
head &rArr; (a 3 b 2)
</pre>
</blockquote>

<br>

<code>(plist-remove <i>plist key</i>)</code> &nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;<i>plist</i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)
<blockquote>
<p>
If the key is in the plist, remove both key and value.
If not, do nothing.
</p>
<p>
~~~FIX_ME; Is this saying new and old when that's not the case except
for handing it an empty list?

Original text:

This procedure returns the new plist, which normally would be the same
as the old plist, unless the old plist is empty.

Maybe better text:

This procedure returns the plist, which is normally the same as the
submitted plist, unless the submitted plist was empty.
</p>
<pre class="example">
(plist-remove! '() 'a) &rArr; ()
</pre>
<pre class="example">
(plist-remove! '(a 1) 'a) &rArr; ()
</pre>
<pre class="example">
(define head (list 'a 1 'b 2 'c 3)) &rArr; &lt;undefined&gt;
</pre>
<pre class="example">
(plist-remove! head 'c) &rArr; (a 1 b 2)
head  &rArr; (a 1 b 2)
</pre>
</blockquote>

<br>

<code>(plist-search! <i>plist key failure success</i>)</code> &nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;<i>multiple values</i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)
<blockquote>
<p>
This procedure is a workhorse for plist insertion, updating, and
deletion.
</p>
<p>
The plist <i>plist</i> is searched for <i>key</i>.
If it is not found, then the <i>failure</i> procedure is tail-called
with two continuation arguments, <i>insert</i> and <i>ignore</i>, and
is expected to tail-call one of them.
</p>
<p>
If <i>key</i> is found, then the <i>success</i> procedure is
tail-called with <i>key</i>, its value, and two continuation
arguments, <i>update</i> and <i>remove</i>, and is expected to
tail-call one of them.
</p>
<p>
It is an error if the continuation arguments are invoked other than in
the tail position in the <i>failure</i> or <i>success</i> procedures.
It is also an error if the <i>failure</i> and <i>success</i>
procedures return to their implicit continuation without invoking one
of their arguments.
</p>
<p>
The behaviors of the continuations are as follows, where <i>obj</i> is
any Scheme object, and in all cases is returned as a second value.
</p>
<ul>
<li>
Invoking <code>(ignore <i>obj</i>)</code> has no effects and returns
<i>plist</i> unchanged.
</li>
<li>
Invoking <code>(insert <i>value obj</i>)</code> returns a plist that
contains all the associations of <i>plist</i>, and in addition a new
association that maps <i>key</i> to <i>value</i>.
</li>
<li>
Invoking <code>(update <i>new-key new-value obj</i>)</code> returns a
plist that contains all the associations of <i>plist</i>, except for
the association whose key is the same as <i>key</i>, which is replaced
by a new association that maps <i>new-key</i> to <i>new-value</i>.
</li>
<li>
Invoking (<i>remove obj</i>) returns a plist that contains all the
associations of <i>plist</i>, except for the association
with <i>key</i>.
</li>
</ul>
<pre class="example">
~~~FIX_ME: insert example &rArr;
</pre>
<pre class="example">
(plist-search! (list 'a 1 'b 2)
               'a
               (lambda (insert ignore)
                 (error "failure called"))
               (lambda (key value update remove)
                 (update key 3 #t)))
  &rArr; (a 3 b 2) #t
</pre>
<pre class="example">
~~~FIX_ME: update failure example &rArr;
</pre>
<pre class="example">
(plist-search! (list 'a 1 'b 2 'c 3)
               'a
               (lambda (insert ignore)
                 (error "failure called"))
               (lambda (key value update remove)
                 (remove #t)))
  &rArr; (b 2 c 3) #t
</pre>
</blockquote>

<br>

<code>(plist-size <i>plist</i>)</code> &nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;<i>exact integer</i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)
<blockquote>
<p>
Returns the number of keys in the plist.
</p>
<pre class="example">
(plist-size '()) &rArr; 0
</pre>
<pre class="example">
(plist-size '(a 1 b 2)) &rArr; 2
</pre>
</blockquote>

<br>

<code>(plist-map! <i>proc plist</i>)</code> &nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;<i>plist</i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)
<blockquote>
<p>
Returns a plist with values modified by proc, which takes two arguments, key and value.
</p>
<pre class="example">
(plist-map! (lambda (key value)
              (* value 2))
            (list 'a 1 'b 2))
  &rArr; (a 2 b 4)
</pre>
<pre class="example">
(plist-map! (lambda (key value)
              8)
            (list 'a 1 'b 2))
  &rArr; (a 8 b 8)
</pre>
</blockquote>

<br>

<code>(plist-filter! <i>predicate plist</i>)</code> &nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;<i>plist</i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)
<blockquote>
<p>
<i>predicate</i> takes two arguments, key and value.
When <i>predicate</i> is satisfied, the key and value are removed from
the returned plist.
</p>
<pre class="example">
(plist-filter! (lambda (key value) #t) '()) &rArr; ()
</pre>
<pre class="example">
(plist-filter! (lambda (key value) #t) '(a 1)) &rArr; ()
</pre>
<pre class="example">
(plist-filter! (lambda (key value) (odd? value))
               (list 'a 1 'b 2 'c 3))
  &rArr; (b 2)
</pre>
</blockquote>

<br>

<code>(plist-for-each <i>proc plist</i>)</code> &nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;<i>unspecified</i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)
<blockquote>
<p>
Calls proc on each key and value, returns unspecified value.
</p>
<pre class="example">
(let ((acc '()))
  (plist-for-each (lambda (key value)
                    (set! acc (cons (cons key value) acc)))
                  '(a 1 b 2))
  acc)
  &rArr; ((b . 2) (a . 1))
</pre>
</blockquote>

<br>

<p><code>(plist->alist <i>plist</i>)</code> &nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;<i>alist</i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)</p>
<p><code>(alist->plist <i>alist</i>)</code> &nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;<i>plist</i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)</p>
<blockquote>
<p>
Converts plists into alists, or <i>vice versa</i>.
</p>
<pre class="example">
(plist->alist '(a 1 b 2)) &rArr; ((a . 1) (b . 2))
</pre>
<pre class="example">
(alist->plist '((a . 1) (b . 2))) &rArr; (a 1 b 2)
</pre>
</blockquote>


<h2 id="implementation">Implementation</h2>

<p>
The <a href="https://github.com/scheme-requests-for-implementation/srfi-???/tree/master/srfi">srfi subdirectory</a>
of the SRFI's repository contains a portable implementation.
<p>


<h2 id="acknowledgements">Acknowledgments</h2>

<p>
Thanks to Marc Nieper-Wi&szlig;kirchen for providing the portable
implementation of this SRFI.
Most of the examples were shamelessly stolen from its test suite.
</p>


<h2 id="copyright">Copyright</h2>
<p>Copyright &copy; 2020 by John Cowan.</p>

<p>
  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:</p>

<p>
  The above copyright notice and this permission notice (including the
  next paragraph) shall be included in all copies or substantial
  portions of the Software.</p>
<p>
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.</p>

  <hr>
  <address>Editor: <a href="mailto:srfi-editors+at+srfi+dot+schemers+dot+org">Arthur A. Gleckler</a></address></body></html>
